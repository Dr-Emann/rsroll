var searchIndex = {};
searchIndex["rollsum"] = {"doc":"","items":[[0,"bup","rollsum","Rolling sum and chunk splitting used by\n`bup` - https://github.com/bup/bup/",null,null],[3,"Bup","rollsum::bup","Rolling checksum method used by `bup`",null,null],[17,"CHUNK_SIZE","","Default chunk size used by `bup`",null,null],[17,"CHUNK_BITS","","Default chunk size used by `bup` (log2)",null,null],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"roll_byte","","",0,null],[11,"digest","","",0,null],[11,"new","","Create new Bup engine with default chunking settings",0,{"inputs":[],"output":{"name":"self"}}],[11,"new_with_chunk_bits","","Create new Bup engine with custom chunking settings",0,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"find_chunk_edge","","Find chunk edge using Bup defaults.",0,null],[11,"count_bits","","Counts the number of low bits set in the rollsum, assuming\nthe digest has the bottom `CHUNK_BITS` bits set to `1`\n(i.e. assuming a digest at a default bup chunk edge, as\nreturned by `find_chunk_edge`).\nBe aware that there&#39;s a deliberate &#39;bug&#39; in this function\nin order to match expected return values from other bupsplit\nimplementations.",0,null],[8,"Engine","rollsum","Rolling sum engine trait",null,null],[16,"Digest","","",1,null],[10,"roll_byte","","Roll over one byte",1,null],[11,"roll","","Roll over a slice of bytes",1,null],[10,"digest","","Return current rolling sum digest",1,null],[11,"find_chunk_edge_cond","","Find the end of the chunk.",1,null]],"paths":[[3,"Bup"],[8,"Engine"]]};
initSearch(searchIndex);
